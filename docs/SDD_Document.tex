\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{float}
\usepackage{enumitem}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{Software Design Document}
\lhead{Face Recognition Attendance System}
\rfoot{Page \thepage}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{
    \textbf{Software Design Document}\\
    \large Face Recognition Attendance System\\
    \vspace{0.5cm}
    \normalsize FastAPI Backend \& React Frontend
}
\author{
    Senior Software Engineering Project\\
    University of [Your University]
}
\date{\today}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

% ============================================================================
% SECTION 1: DESIGN VIEWPOINTS
% ============================================================================
\section{Design Viewpoints}

This section presents the architectural and behavioral views of the Face Recognition Attendance System through five key diagrams. Each diagram captures a different perspective of the system's structure and interactions.

% ----------------------------------------------------------------------------
\subsection{Sequence Diagram}

The sequence diagram illustrates the temporal flow of messages between system components during a typical attendance marking scenario. The flow begins when a student approaches the camera terminal.

The Edge Agent captures the student's face and sends the image data to the AI Service via the API Gateway. The AI Service performs face encoding using the face\_recognition library, then queries the Auth Service to match the encoding against registered students. Upon successful identification, the Attendance Service records the attendance entry with timestamp and status (present, late, or absent based on class schedule). Finally, the Notification Service dispatches a real-time WebSocket message to update the mentor's dashboard.

A parallel flow handles failed recognition attempts. When the AI Service cannot match a face encoding, it returns an "unknown" status. The system logs this attempt for security auditing but does not create an attendance record. The mentor receives a notification about the unrecognized individual.

\begin{figure}[h!]
\centering
% \includegraphics[width=0.9\textwidth]{sequence_diagram.png}
\caption{Sequence Diagram: Attendance Marking Flow}
\label{fig:sequence_diagram}
\end{figure}

% ----------------------------------------------------------------------------
\subsection{Use Case Diagram}

The use case diagram defines three primary actors: Student, Mentor, and Admin. Each actor interacts with distinct system functionalities based on their role permissions.

Students can enroll their face (capturing multiple angles for robust recognition), view their personal attendance history, check their class schedule, and receive notifications about attendance status. The face enrollment process requires capturing 3-5 images from different angles to build a reliable face encoding profile.

Mentors manage their assigned classes. They can start and stop attendance sessions, view real-time attendance feeds during active sessions, manually override attendance records (marking excused absences), and generate attendance reports for their courses. Mentors see only students enrolled in their specific classes.

Admins hold full system control. They manage user accounts (create, activate, deactivate), configure courses and class schedules, assign mentors to courses, manage room allocations with conflict detection, and access system-wide analytics. The Admin cannot directly mark attendance—this separation prevents administrative override of biometric verification.

\begin{figure}[h!]
\centering
% \includegraphics[width=0.85\textwidth]{usecase_diagram.png}
\caption{Use Case Diagram: Actor Interactions}
\label{fig:usecase_diagram}
\end{figure}

% ----------------------------------------------------------------------------
\subsection{Context Diagram}

The context diagram positions the Face Recognition Attendance System within its operational environment, showing external entities and data flows.

The system interfaces with five external entities. Camera Hardware provides raw video streams to the Edge Agent component. The PostgreSQL Database stores all persistent data including user profiles, face encodings, attendance records, and schedule information. An SMTP Server handles email notifications for critical alerts (account activation, password resets). The Browser Client represents the React frontend application accessing the system through REST APIs. WebSocket Connections enable real-time bidirectional communication for live attendance feeds.

Data flows include: video frames entering from cameras, JSON API requests/responses with the browser, attendance records persisted to the database, notification payloads sent via WebSocket, and email messages dispatched through SMTP.

\begin{figure}[h!]
\centering
% \includegraphics[width=0.8\textwidth]{context_diagram.png}
\caption{Context Diagram: System Boundaries}
\label{fig:context_diagram}
\end{figure}

% ----------------------------------------------------------------------------
\subsection{Class Diagram}

The class diagram reveals the object-oriented structure of the backend services. The design follows a layered architecture with clear separation between API routes, services, repositories, and models.

The \texttt{User} base class contains common attributes: id (UUID), email, full\_name, hashed\_password, role, and is\_active. Three specialized classes inherit from User: \texttt{Student} adds student\_id and group attributes; \texttt{Mentor} adds a courses relationship; \texttt{Admin} requires no additional attributes but gains elevated permissions through the role field.

The \texttt{Course} class aggregates multiple \texttt{Class} instances (one-to-many). Each Class belongs to one Course and optionally references a Mentor. The \texttt{Enrollment} class implements a many-to-many relationship between Student and Class, tracking enrollment timestamps.

\texttt{AttendanceSession} represents an active attendance-taking period. It references a Class and contains a collection of \texttt{AttendanceRecord} entries. Each AttendanceRecord links to a Student and stores status (present/absent/late/excused), timestamp, and recognition confidence score.

The \texttt{FaceEncoding} class stores the 128-dimensional face vector generated by the AI service, linked to a Student through a one-to-many relationship (students can have multiple encodings for accuracy).

\begin{figure}[h!]
\centering
% \includegraphics[width=0.95\textwidth]{class_diagram.png}
\caption{Class Diagram: Domain Model Structure}
\label{fig:class_diagram}
\end{figure}

% ----------------------------------------------------------------------------
\subsection{Architecture Diagram}

The architecture follows a microservices pattern with an API Gateway routing requests to specialized services. This design choice stemmed from the need to scale the AI processing independently from CRUD operations.

The \textbf{API Gateway} serves as the single entry point. It handles JWT authentication, request routing based on URL prefixes, and CORS configuration. All requests pass through authentication middleware before reaching downstream services.

Six backend services operate behind the gateway:
\begin{itemize}[noitemsep]
    \item \textbf{Auth Service}: User management, JWT token generation, password hashing with bcrypt
    \item \textbf{Schedule Service}: Courses, classes, enrollments, room conflict detection
    \item \textbf{Attendance Service}: Session management, record creation, status calculations
    \item \textbf{AI Service}: Face detection, encoding generation, recognition matching
    \item \textbf{Notification Service}: WebSocket management, real-time event broadcasting
    \item \textbf{Stats Service}: Analytics aggregation, attendance rate calculations
\end{itemize}

The \textbf{Edge Agent} runs separately on devices with camera access. It captures frames, performs initial face detection locally, and sends cropped face images to the AI Service. This reduces bandwidth and centralizes the heavy encoding computation.

The \textbf{React Frontend} communicates exclusively through the API Gateway. It maintains local state with React Context for authentication and notifications, using Axios for HTTP requests and native WebSocket for real-time updates.

\begin{figure}[h!]
\centering
% \includegraphics[width=0.95\textwidth]{architecture_diagram.png}
\caption{Architecture Diagram: Microservices Layout}
\label{fig:architecture_diagram}
\end{figure}

% ============================================================================
% SECTION 2: DATA DESIGN
% ============================================================================
\section{Data Design}

\subsection{Database Schema Overview}

PostgreSQL serves as the primary datastore. The schema design prioritizes referential integrity and query performance for attendance lookups.

\subsection{Core Tables and Relationships}

\paragraph{Users Table}
Stores all system users with role-based differentiation. The \texttt{role} column uses an ENUM type constrained to 'student', 'mentor', or 'admin'. Students have additional nullable fields for \texttt{student\_id} and \texttt{group}. Passwords are never stored in plaintext—only bcrypt hashes with a cost factor of 12.

\paragraph{Courses and Classes}
A Course represents a subject (e.g., "Database Systems"). A Class represents a scheduled session of that course (e.g., "Database Systems - Section A, Monday 9:00 AM"). This separation allows multiple sections of the same course with different mentors and schedules.

The \texttt{classes} table includes:
\begin{itemize}[noitemsep]
    \item \texttt{course\_id}: Foreign key to courses
    \item \texttt{mentor\_id}: Optional foreign key to users (role=mentor)
    \item \texttt{room\_number}: String identifier for physical location
    \item \texttt{day\_of\_week}: ENUM for scheduling
    \item \texttt{schedule\_time}: TIME type for class start
    \item \texttt{state}: ENUM ('inactive', 'active', 'completed')
\end{itemize}

\paragraph{Course-Mentor Association}
A junction table \texttt{course\_mentors} implements many-to-many between courses and mentors. A mentor can teach multiple courses; a course can have multiple mentors (for different sections).

\paragraph{Enrollments}
The \texttt{enrollments} table links students to classes. Composite unique constraint on (student\_id, class\_id) prevents duplicate enrollments.

\paragraph{Attendance Records}
Each record captures: session\_id, student\_id, status, marked\_at timestamp, and confidence\_score (0.0-1.0 from face recognition). An index on (session\_id, student\_id) accelerates lookups during active sessions.

\paragraph{Face Encodings}
Stored as a 128-element float array (PostgreSQL ARRAY type). Each student can have multiple encodings. The recognition algorithm compares incoming faces against all encodings for a student and uses the best match.

\subsection{Indexing Strategy}

Primary indexes exist on all UUID primary keys. Additional indexes:
\begin{itemize}[noitemsep]
    \item \texttt{users(email)}: Unique index for login lookups
    \item \texttt{classes(day\_of\_week, schedule\_time)}: Composite for schedule queries
    \item \texttt{attendance\_records(session\_id, student\_id)}: Composite for session lookups
    \item \texttt{enrollments(student\_id)}: For fetching student schedules
\end{itemize}

% ============================================================================
% SECTION 3: USER INTERFACE DESIGN
% ============================================================================
\section{User Interface Design}

\subsection{Design Philosophy}

The interface follows a "progressive disclosure" principle. Users see only what they need for their current task. Complex features hide behind intuitive interactions rather than cluttering the initial view.

We adopted a component-based architecture using shadcn/ui built on Radix primitives. This gave us accessible, unstyled components that we customized with Tailwind CSS. The result: consistent behavior across browsers with our own visual identity.

\subsection{Layout Strategy}

\paragraph{Shell Layout}
Authenticated pages share a common shell: collapsible sidebar on the left, main content area on the right. The sidebar shows role-appropriate navigation items. Students see: Dashboard, Schedule, Attendance, Face Enrollment. Mentors see: Dashboard, Schedule, Attendance (with session controls), Courses. Admins see everything plus Users, Classes, and system configuration.

\paragraph{Dashboard Design}
Each role gets a tailored dashboard. Students see their enrolled courses count, upcoming classes, and personal attendance rate. Mentors see their teaching load, student count across their classes, and quick-action buttons to start sessions. Admins see system-wide metrics: total users by role, overall attendance rates, and management shortcuts.

\paragraph{Form Patterns}
All forms follow the same structure: labels above inputs, validation messages below, primary action button on the left, cancel on the right. Required fields marked with asterisks. Dropdowns populate dynamically—selecting a course filters the mentor dropdown to show only assigned mentors.

\paragraph{Table Views}
Data tables support sorting (click column headers), filtering (dropdown selectors), and search (text input). The Classes page groups results by the current sort field, showing section headers like "Monday" or "Room 101" depending on sort selection.

\paragraph{Responsive Behavior}
The sidebar collapses to icons on tablet widths and becomes a hamburger menu on mobile. Cards stack vertically on narrow screens. Tables scroll horizontally when needed rather than breaking layout.

\subsection{Color and Typography}

The light theme uses a neutral gray palette with purple accent colors (primary actions, active states). Status colors follow conventions: green for success/present, red for errors/absent, yellow for warnings/late, blue for informational.

Typography uses Inter font family. Headings use semibold weight; body text uses regular. Size scale follows Tailwind defaults: text-sm for secondary info, text-base for body, text-lg for card titles, text-3xl for page headings.

% ============================================================================
% SECTION 4: PROJECT PLAN & TASK DISTRIBUTION
% ============================================================================
\section{Project Plan and Task Distribution}

\subsection{Team Roles}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{Role} & \textbf{Member} & \textbf{Responsibilities} \\
\hline
Project Lead & [Name] & Architecture decisions, code reviews, integration testing, documentation oversight \\
\hline
Backend Developer & [Name] & FastAPI services, database design, API endpoints, authentication system \\
\hline
Frontend Developer & [Name] & React components, state management, UI/UX implementation, responsive design \\
\hline
AI/ML Engineer & [Name] & Face recognition pipeline, encoding algorithms, Edge Agent development \\
\hline
QA Engineer & [Name] & Test case design, automated testing, bug tracking, performance testing \\
\hline
\end{tabular}
\caption{Team Role Assignments}
\label{tab:team_roles}
\end{table}

\subsection{Development Timeline}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Phase} & \textbf{Duration} & \textbf{Deliverables} \\
\hline
Phase 1: Foundation & Weeks 1-2 & Project setup, database schema, basic auth, user CRUD \\
\hline
Phase 2: Core Features & Weeks 3-5 & Schedule management, enrollment system, attendance recording \\
\hline
Phase 3: AI Integration & Weeks 6-8 & Face detection, encoding storage, recognition matching \\
\hline
Phase 4: Real-time & Weeks 9-10 & WebSocket notifications, live attendance feed, Edge Agent \\
\hline
Phase 5: Polish & Weeks 11-12 & UI refinement, testing, documentation, deployment prep \\
\hline
\end{tabular}
\caption{Development Timeline}
\label{tab:timeline}
\end{table}

